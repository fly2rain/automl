# ------------------------------------------------------------------------------------------------
#
# By: Feiyun Zhu @ Sams Club Technology @ Mar 25, 2019
#
#   - revised the code by Jatin Kumar Mandav
#
# Generating XML Files for Darkflow from .txt files generated by OpenLabeling
# USAGE: generate_xml.py [-h] [--format {yolo,voc}] [--bbox_txt BBOX_TXT]
#                       [--img_dir IMG_DIR] [--class_list CLASS_LIST]
#                       [--save_dir SAVE_DIR]
#
# Generate XML Files from .txt file
#
# optional arguments:
#  -h, --help                show this help message and exit
#  --format {yolo,voc}       Bounding box format | Deafult: yolo
#  --bbox_txt BBOX_TXT       Path to bbox_txt dir generated by OpenLabeling | Deafult: bbox_txt/
#  --img_dir IMG_DIR         Path to Images folder | Default: images/
#  --class_list CLASS_LIST   Path to class_list.txt file | Default: class_list.txt
#  --save_dir SAVE_DIR   Where to save XML Files. | Default: annotations_xml/
#
# ------------------------------------------------------------------------------------------------

from lxml import etree
import xml.etree.cElementTree as ET
import cv2
import os
import argparse
import textwrap


# from fuzzywuzzy import fuzz
## The function is to creat the full dst path according to the src folders 
def creat_full_dst_path(src, dst, root):
    dst_path = root.replace(src, dst, 1)  # only replace the 1st item
    if not os.path.exists(dst_path):
        os.makedirs(dst_path)
    return dst_path


def write_xml(saveDir, imagefolder, imagename, imgWidth, imgHeight, depth, bounding_boxes, pose="Unspecified"):
    annotation = ET.Element("annotation")
    ET.SubElement(annotation, 'folder').text = str(imagefolder)
    ET.SubElement(annotation, 'filename').text = str(imagename)
    size = ET.SubElement(annotation, 'size')
    ET.SubElement(size, 'width').text = str(imgWidth)
    ET.SubElement(size, 'height').text = str(imgHeight)
    ET.SubElement(size, 'depth').text = str(depth)

    ET.SubElement(annotation, 'segmented').text = '0'

    for box in bounding_boxes:
        obj = ET.SubElement(annotation, 'object')

        ET.SubElement(obj, 'name').text = str(box[0])
        ET.SubElement(obj, 'pose').text = str(pose)
        ET.SubElement(obj, 'truncated').text = '0'
        ET.SubElement(obj, 'difficult').text = '0'

        bbox = ET.SubElement(obj, 'bndbox')

        ET.SubElement(bbox, 'xmin').text = str(box[1])
        ET.SubElement(bbox, 'ymin').text = str(box[2])
        ET.SubElement(bbox, 'xmax').text = str(box[3])
        ET.SubElement(bbox, 'ymax').text = str(box[4])

    xml_str = ET.tostring(annotation)
    root = etree.fromstring(xml_str)
    xml_str = etree.tostring(root, pretty_print=True)
    save_path = os.path.join(saveDir, os.path.splitext(imagename)[0] + ".xml")

    with open(save_path, 'wb') as temp_xml:
        temp_xml.write(xml_str)


# def yolo_to_x_y(x_center, y_center, x_width, y_height, width, height):
#     x_center *= width
#     y_center *= height
#     x_width *= width
#     y_height *= height
#     x_width /= 2.0
#     y_height /= 2.0
#     return int(x_center - x_width), int(y_center - y_height), int(x_center + x_width), int(y_center + y_height)


def xywh_2_xyxy_int(x, y, w, h, width, height):
    x1, y1, x2, y2 = xywh_2_xyxy(x, y, w, h)

    x1, x2 = round(x1 * width), round(x2 * width)
    y1, y2 = round(y1 * height), round(y2 * height)
    return x1, y1, x2, y2


def put_into_range(num, low_t=0.0, high_t=1.0):
    if isinstance(num, (float, int)):
        return min(max(num, low_t), high_t)
    elif isinstance(num, (tuple, list)):
        return [min(max(low_t, x), high_t) for x in num]
    else:
        raise ValueError(f"The input {num} is not float, int, tuple or list.\n")


def xywh_2_xyxy(x, y, w, h):
    w_2, h_2 = w / 2.0, h / 2.0

    x1, x2 = x - w_2, x + w_2
    y1, y2 = y - h_2, y + h_2

    x1, y1, x2, y2 = put_into_range((x1, y1, x2, y2))
    return x1, y1, x2, y2


def read_bounding_boxes_from_txt(txt_src, labels, format, imgWidth, imgHeight):
    bounding_boxes = []
    if not txt_src: return bounding_boxes

    with open(txt_src) as f:
        content = f.readlines()

    for line in content:
        values_str = line.split()[:5]
        if format == "yolo":
            class_index, x_center, y_center, x_width, y_height = map(float, values_str)
            class_index = int(class_index)
            bboxx1, bboxy1, bboxx2, bboxy2 = xywh_2_xyxy_int(x_center, y_center, x_width, y_height, imgWidth, imgHeight)
            if x_center == int(x_center):
                error = ("You selected the 'yolo' format but your labels "
                         "seem to be in a different format. Consider "
                         "removing your old label files.")
                raise Exception(textwrap.fill(error, 70))
        else:
            try:
                x1, y1, x2, y2, class_index = map(int, values_str)
            except ValueError:
                error = ("You selected the 'voc' format but your labels "
                         "seem to be in a different format. Consider "
                         "removing your old label files.")
                raise Exception(textwrap.fill(error, 70))
            bboxx1, bboxy1, bboxx2, bboxy2 = x1 - 1, y1 - 1, x2 - 1, y2 - 1

        label_name = labels[class_index]

        bounding_boxes.append((label_name, bboxx1, bboxy1, bboxx2, bboxy2))
    return bounding_boxes


def main_txt_2_xml(src, dst, format, class_list):
    with open(class_list, 'r') as f:
        labels = f.readlines()

    for i, x in enumerate(labels):
        labels[i] = x.strip().split("\n")[0]  # get the class name itself out.

    cnt = 0
    for root, _, files in os.walk(src, False):
        # get the full dst_path 
        saveDir = creat_full_dst_path(src, dst, root)

        for file in files:
            filename, ext = os.path.splitext(file)
            # print("root ={}\t imagename = {}\t ext = {}".format(root, imagename, ext))

            # xml_file = filename + ".xml"
            if ext not in ['.jpg', '.JPG', '.jpeg', '.png']:
                continue

            img_full_path = os.path.join(root, file)
            txt_full_path = os.path.join(root, filename + ".txt")
            img = cv2.imread(img_full_path)
            print("{}. {}\t {}".format(cnt, root, file))
            cnt += 1

            imgHeight, imgWidth, depth = img.shape
            bounding_boxes = read_bounding_boxes_from_txt(txt_full_path, labels, format, imgWidth, imgHeight)
            write_xml(saveDir, root, filename, imgWidth, imgHeight, depth, bounding_boxes, pose="Unspecified")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Generate XML Files from .txt file")
    parser.add_argument('-format', default='yolo', type=str, choices=['yolo', 'voc'],
                        help="Bounding box format | Deafult: yolo")
    parser.add_argument('-src', default='images/', type=str, help='Path to Images folder | Default: images/')
    parser.add_argument('-dst', default='xml/', type=str, help='Path to txt label folder | Default: xml/')
    parser.add_argument('-class_list', default='class_list.txt', type=str,
                        help='Path to class_list.txt file | Default: class_list.txt')
    args = parser.parse_args()

    format = args.format
    src = args.src  # the image and txt label are supposed to be in the same folder
    dst = args.dst  # the folder to store the resulted xml file.
    class_list = args.class_list

    main_txt_2_xml(src, dst, format, class_list)
